<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>XEffects: effectHandler Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>effectHandler Class Reference</h1><!-- doxytag: class="effectHandler" -->Main effect handling class, use this to apply shadows and effects.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;effectWrapper.h&gt;</code>
<p>
<a href="classeffect_handler-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeffect_handler.html#8ba04c9946a334d59a32c9f8347f0779">effectHandler</a> (irr::IrrlichtDevice *dev, irr::core::dimension2d&lt; irr::s32 &gt; mapSize, irr::core::stringc shaderFolder=&quot;&quot;, irr::core::dimension2d&lt; irr::s32 &gt; screenRTTSize=irr::core::dimension2d&lt; irr::s32 &gt;(0, 0))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeffect_handler.html#7d7271259d5fdc0e897fdc9d16512f52">addEffectToNode</a> (irr::scene::ISceneNode *node, E_EFFECT_TYPE etype)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4bcaaccc7c2244e9cb2a7f325a5e2f01"></a><!-- doxytag: member="effectHandler::addShadowLight" ref="4bcaaccc7c2244e9cb2a7f325a5e2f01" args="(const SShadowLight &amp;shadowLight)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeffect_handler.html#4bcaaccc7c2244e9cb2a7f325a5e2f01">addShadowLight</a> (const SShadowLight &amp;shadowLight)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a shadow light. Check out the shadow light constructor for more information. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="be76e94899879f083f7e52eb3dcca99b"></a><!-- doxytag: member="effectHandler::getShadowLight" ref="be76e94899879f083f7e52eb3dcca99b" args="(irr::u32 index)" -->
SShadowLight &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeffect_handler.html#be76e94899879f083f7e52eb3dcca99b">getShadowLight</a> (irr::u32 index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a reference to a shadow light. You may get the max amount from getShadowLightCount. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ab16432b298119bf06803f2fba3c5924"></a><!-- doxytag: member="effectHandler::getShadowLightCount" ref="ab16432b298119bf06803f2fba3c5924" args="() const" -->
const irr::u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeffect_handler.html#ab16432b298119bf06803f2fba3c5924">getShadowLightCount</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the current number of shadow lights. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ef33a1ec25b7eb84feb7e7304661bae4"></a><!-- doxytag: member="effectHandler::getShadowMapTexture" ref="ef33a1ec25b7eb84feb7e7304661bae4" args="()" -->
irr::video::ITexture *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeffect_handler.html#ef33a1ec25b7eb84feb7e7304661bae4">getShadowMapTexture</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the shadow map texture. This will usually have the info from the last shadow light added. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">irr::video::ITexture *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeffect_handler.html#18385b4dde3ccb0cbdb91e72f38a5c81">getDepthMapTexture</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeffect_handler.html#39223607a08945b00af36016da33e27a">addNodeToDepthPass</a> (irr::scene::ISceneNode *node)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeffect_handler.html#e9842995ec33ea517e52ab78c54e56b4">removeNodeFromDepthPass</a> (irr::scene::ISceneNode *node)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeffect_handler.html#cf76fadcb37394b268846a8ef588190c">enableDepthPass</a> (bool enableDepthPass)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="38c734362b4c3ea0ec2a2e8cc8902dee"></a><!-- doxytag: member="effectHandler::removeShadowFromNode" ref="38c734362b4c3ea0ec2a2e8cc8902dee" args="(irr::scene::ISceneNode *node)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeffect_handler.html#38c734362b4c3ea0ec2a2e8cc8902dee">removeShadowFromNode</a> (irr::scene::ISceneNode *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes shadows from a scene node. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeffect_handler.html#6f1bb28bb2eb67c83910321c0a25f41f">update</a> (irr::video::ITexture *outputTarget=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeffect_handler.html#13ec31bf83ccc8826d34e26ef8553f50">addShadowToNode</a> (irr::scene::ISceneNode *node, E_FILTER_TYPE filterType=EFT_NONE, E_SHADOW_MODE shadowMode=ESM_BOTH)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0bc79b4811a8889c6bebf89714db7b6c"></a><!-- doxytag: member="effectHandler::getTime" ref="0bc79b4811a8889c6bebf89714db7b6c" args="()" -->
irr::f32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeffect_handler.html#0bc79b4811a8889c6bebf89714db7b6c">getTime</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the device time divided by 100, for use with the shader callbacks. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5e3ed5167e6f6a72204c4953fd3e8087"></a><!-- doxytag: member="effectHandler::setClearColour" ref="5e3ed5167e6f6a72204c4953fd3e8087" args="(irr::video::SColor ClearCol)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeffect_handler.html#5e3ed5167e6f6a72204c4953fd3e8087">setClearColour</a> (irr::video::SColor ClearCol)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the scene clear colour, for when the scene is cleared before smgr-&gt;drawAll(). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeffect_handler.html#cb51a95191ff8e8ad302c28074bd455e">addPostProcessingEffect</a> (irr::s32 MaterialType)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c96153ff6382495932612648415849d4"></a><!-- doxytag: member="effectHandler::removePostProcessingEffect" ref="c96153ff6382495932612648415849d4" args="(irr::s32 MaterialType)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeffect_handler.html#c96153ff6382495932612648415849d4">removePostProcessingEffect</a> (irr::s32 MaterialType)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the first encountered post processing effect with the specified material type. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeffect_handler.html#e4f92c01dfd9a3eee23f14b9745f4698">addPostProcessingEffectFromFile</a> (const irr::core::stringc &amp;filename)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const CScreenQuad &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeffect_handler.html#8e7d6a4f827b47da4a9a1925f7176a34">getScreenQuad</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="35b5855a6efc4a7a6edc27f01ffa58a8"></a><!-- doxytag: member="effectHandler::setActiveSceneManager" ref="35b5855a6efc4a7a6edc27f01ffa58a8" args="(irr::scene::ISceneManager *smgrIn)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeffect_handler.html#35b5855a6efc4a7a6edc27f01ffa58a8">setActiveSceneManager</a> (irr::scene::ISceneManager *smgrIn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the active scene manager. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="281a64bc68ccd743df58a3994d4d8433"></a><!-- doxytag: member="effectHandler::getActiveSceneManager" ref="281a64bc68ccd743df58a3994d4d8433" args="()" -->
irr::scene::ISceneManager *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeffect_handler.html#281a64bc68ccd743df58a3994d4d8433">getActiveSceneManager</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the active scene manager. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d56e19956f0332e331ad7ae19617dc9d"></a><!-- doxytag: member="effectHandler::setPostProcessingUserTexture" ref="d56e19956f0332e331ad7ae19617dc9d" args="(irr::video::ITexture *userTexture)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeffect_handler.html#d56e19956f0332e331ad7ae19617dc9d">setPostProcessingUserTexture</a> (irr::video::ITexture *userTexture)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This allows the user to specify a custom, fourth texture to be used in the post-processing effects. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7476e6345644f3a031a1b8f881e965db"></a><!-- doxytag: member="effectHandler::getEffectMaterialType" ref="7476e6345644f3a031a1b8f881e965db" args="(E_EFFECT_TYPE etype) const " -->
irr::s32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeffect_handler.html#7476e6345644f3a031a1b8f881e965db">getEffectMaterialType</a> (E_EFFECT_TYPE etype) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the material type associated with the effect. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="02f00946ac340ea849b5a77f14b05e85"></a><!-- doxytag: member="effectHandler::setAmbientColor" ref="02f00946ac340ea849b5a77f14b05e85" args="(irr::video::SColor ambientColour)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeffect_handler.html#02f00946ac340ea849b5a77f14b05e85">setAmbientColor</a> (irr::video::SColor ambientColour)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the global ambient color for shadowed scene nodes. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fd4cd307d8f484da0612c7fed1f1bf62"></a><!-- doxytag: member="effectHandler::getAmbientColor" ref="fd4cd307d8f484da0612c7fed1f1bf62" args="() const" -->
irr::video::SColor&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeffect_handler.html#fd4cd307d8f484da0612c7fed1f1bf62">getAmbientColor</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the global ambient color. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Main effect handling class, use this apply shadows and effects. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="8ba04c9946a334d59a32c9f8347f0779"></a><!-- doxytag: member="effectHandler::effectHandler" ref="8ba04c9946a334d59a32c9f8347f0779" args="(irr::IrrlichtDevice *dev, irr::core::dimension2d&lt; irr::s32 &gt; mapSize, irr::core::stringc shaderFolder=&quot;&quot;, irr::core::dimension2d&lt; irr::s32 &gt; screenRTTSize=irr::core::dimension2d&lt; irr::s32 &gt;(0, 0))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">effectHandler::effectHandler           </td>
          <td>(</td>
          <td class="paramtype">irr::IrrlichtDevice *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::core::dimension2d&lt; irr::s32 &gt;&nbsp;</td>
          <td class="paramname"> <em>mapSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::core::stringc&nbsp;</td>
          <td class="paramname"> <em>shaderFolder</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::core::dimension2d&lt; irr::s32 &gt;&nbsp;</td>
          <td class="paramname"> <em>screenRTTSize</em> = <code>irr::core::dimension2d&lt;&nbsp;irr::s32&nbsp;&gt;(0,&nbsp;0)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
To initialize the <a class="el" href="classeffect_handler.html">effectHandler</a>, pass it the current Irrlicht device, the shadow map size and the folder where the shaders are contained. You may also pass an alternate size for the post-processing RTT (Using the default initializes it to the same size as the screen.) 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="7d7271259d5fdc0e897fdc9d16512f52"></a><!-- doxytag: member="effectHandler::addEffectToNode" ref="7d7271259d5fdc0e897fdc9d16512f52" args="(irr::scene::ISceneNode *node, E_EFFECT_TYPE etype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void effectHandler::addEffectToNode           </td>
          <td>(</td>
          <td class="paramtype">irr::scene::ISceneNode *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E_EFFECT_TYPE&nbsp;</td>
          <td class="paramname"> <em>etype</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds an effect to a scene node by applying a shader material. Look at the E_EFFECT_TYPE enums for the various effect types available. 
</div>
</div><p>
<a class="anchor" name="18385b4dde3ccb0cbdb91e72f38a5c81"></a><!-- doxytag: member="effectHandler::getDepthMapTexture" ref="18385b4dde3ccb0cbdb91e72f38a5c81" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">irr::video::ITexture* effectHandler::getDepthMapTexture           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the screen depth map texture if the depth pass is enabled. This is unrelated to the shadow map, and is meant to be used for post processing effects that require screen depth info, eg. DOF or SSAO. 
</div>
</div><p>
<a class="anchor" name="39223607a08945b00af36016da33e27a"></a><!-- doxytag: member="effectHandler::addNodeToDepthPass" ref="39223607a08945b00af36016da33e27a" args="(irr::scene::ISceneNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void effectHandler::addNodeToDepthPass           </td>
          <td>(</td>
          <td class="paramtype">irr::scene::ISceneNode *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is now unrelated to shadow mapping. It simply adds a node to the screen space depth map render, for use with post processing effects that require screen depth info. If you want the functionality of the old method (A node that only casts but does not recieve shadows, use addShadowToNode with the ESM_CAST shadow mode. 
</div>
</div><p>
<a class="anchor" name="e9842995ec33ea517e52ab78c54e56b4"></a><!-- doxytag: member="effectHandler::removeNodeFromDepthPass" ref="e9842995ec33ea517e52ab78c54e56b4" args="(irr::scene::ISceneNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void effectHandler::removeNodeFromDepthPass           </td>
          <td>(</td>
          <td class="paramtype">irr::scene::ISceneNode *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is now unrelated to shadow mapping. It simply removes a node to the screen space depth map render, for use with post processing effects that require screen depth info. 
</div>
</div><p>
<a class="anchor" name="cf76fadcb37394b268846a8ef588190c"></a><!-- doxytag: member="effectHandler::enableDepthPass" ref="cf76fadcb37394b268846a8ef588190c" args="(bool enableDepthPass)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void effectHandler::enableDepthPass           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enableDepthPass</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables/disables an additional pass before applying post processing effects (If there are any) which records screen depth info to the depth buffer for use with post processing effects that require screen depth info, such as SSAO or DOF. For nodes to be rendered in this pass, they must first be added using addNodeToDepthPass(SceneNode). 
</div>
</div><p>
<a class="anchor" name="6f1bb28bb2eb67c83910321c0a25f41f"></a><!-- doxytag: member="effectHandler::update" ref="6f1bb28bb2eb67c83910321c0a25f41f" args="(irr::video::ITexture *outputTarget=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void effectHandler::update           </td>
          <td>(</td>
          <td class="paramtype">irr::video::ITexture *&nbsp;</td>
          <td class="paramname"> <em>outputTarget</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Updates the effects handler. This must be done between IVideoDriver::beginScene and IVideoDriver::endScene. This function now replaces smgr-&gt;drawAll(). So place it where smgr-&gt;drawAll() would normally go. Please note that the clear colour from IVideoDriver::beginScene is not preserved, so you must instead specify the clear colour using effectHandler::setClearColour(Colour). A render target may be passed as the output target, else rendering will commence on the backbuffer. 
</div>
</div><p>
<a class="anchor" name="13ec31bf83ccc8826d34e26ef8553f50"></a><!-- doxytag: member="effectHandler::addShadowToNode" ref="13ec31bf83ccc8826d34e26ef8553f50" args="(irr::scene::ISceneNode *node, E_FILTER_TYPE filterType=EFT_NONE, E_SHADOW_MODE shadowMode=ESM_BOTH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void effectHandler::addShadowToNode           </td>
          <td>(</td>
          <td class="paramtype">irr::scene::ISceneNode *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E_FILTER_TYPE&nbsp;</td>
          <td class="paramname"> <em>filterType</em> = <code>EFT_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E_SHADOW_MODE&nbsp;</td>
          <td class="paramname"> <em>shadowMode</em> = <code>ESM_BOTH</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a shadow to the scene node. The filter type specifies how many shadow map samples to take, a higher value can produce a smoother or softer result. The shadow mode can be either ESM_BOTH, ESM_CAST, or ESM_RECEIVE. ESM_BOTH casts and receives shadows, ESM_CAST only casts shadows, and is unaffected by shadows or lighting, and ESM_RECEIVE only receives but does not cast shadows. 
</div>
</div><p>
<a class="anchor" name="cb51a95191ff8e8ad302c28074bd455e"></a><!-- doxytag: member="effectHandler::addPostProcessingEffect" ref="cb51a95191ff8e8ad302c28074bd455e" args="(irr::s32 MaterialType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void effectHandler::addPostProcessingEffect           </td>
          <td>(</td>
          <td class="paramtype">irr::s32&nbsp;</td>
          <td class="paramname"> <em>MaterialType</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A very easy to use post processing function. Simply add a material type to apply to the screen as a post processing effect and it will be applied. You can add as many material types as you desire, and they will be double buffered and executed in sequance. For the material types, I recommend using "ScreenQuadCB" as the callback and refering to the texture names that are passed (When using OpenGL, in DirectX uniforms are not required to bind textures). Please note that this will only work in OpenGL on vanilla Irrlicht, DX requires the large RTT patch to be able to create sufficiently sized rendertargets for post processing. (Or you can just remove the engine check for Pow2).<p>
The structure of the textures is as follows:<p>
Texture1 - "ColorMapSampler" This is passed on from the previous post processing effect as they are executed in sequance. For example, if you do a horizontal blur on the first post processing material, then a vertical blur in the second material, you will use this sampler to access the post processed data of the horizontal blur when it is time to do the vertical blur. If accessed from the first post processing material, it will just contain the untainted screen map data.<p>
Texture2 - "ScreenMapSampler" The second texture will always contain the untainted screen map data, from when the scene is first rendered. It will remain unchanged no matter how many post processing materials are applied. This kind of data is necessary, for example in bloom or DOF, you would require a copy of the blurred scene data and a copy of the normal untainted, unblurred screen data, and mix between them based on certain factors such as depth or luminance.<p>
Texture3 - "DepthMapSampler" If a depth pass has been enabled using enableDepthPass, then this sampler will contain the screen space depth information. For better quality this is encoded to 16bits, and can be decoded like so: Texture.red + (Texture.green / 256.0f); That is by adding the red channel to the green channel which is first divided by 256. The data can still be used without decoding, in 8 bit precision, by just accessing the red component of the texture. Though this is not recommended as 8 bit precision is usually not sufficient for modern post processing effects. 
</div>
</div><p>
<a class="anchor" name="e4f92c01dfd9a3eee23f14b9745f4698"></a><!-- doxytag: member="effectHandler::addPostProcessingEffectFromFile" ref="e4f92c01dfd9a3eee23f14b9745f4698" args="(const irr::core::stringc &amp;filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void effectHandler::addPostProcessingEffectFromFile           </td>
          <td>(</td>
          <td class="paramtype">const irr::core::stringc &amp;&nbsp;</td>
          <td class="paramname"> <em>filename</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a post processing effect by reading a pixel shader from a file. The vertex shader is taken care of. The vertex shader will pass the correct screen quad texture coordinates via the TEXCOORD0 semantic in Direct3D or the gl_TexCoord[0] varying in OpenGL. 
</div>
</div><p>
<a class="anchor" name="8e7d6a4f827b47da4a9a1925f7176a34"></a><!-- doxytag: member="effectHandler::getScreenQuad" ref="8e7d6a4f827b47da4a9a1925f7176a34" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const CScreenQuad&amp; effectHandler::getScreenQuad           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the screen quad scene node. This is not required in any way, but some advanced users may want to adjust its material settings accordingly. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>My Documents/Visual Studio 2005/Projects/ShadowMap/XEffects/Source/effectWrapper.h<li>My Documents/Visual Studio 2005/Projects/ShadowMap/XEffects/Source/effectWrapper.cpp</ul>
<hr size="1"><address style="align: right;"><small>Generated on Wed Oct 15 00:29:28 2008 for XEffects by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
