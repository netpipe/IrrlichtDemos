// Copyright NVIDIA Corporation 2002-2005
// TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, THIS SOFTWARE IS PROVIDED
// *AS IS* AND NVIDIA AND ITS SUPPLIERS DISCLAIM ALL WARRANTIES, EITHER EXPRESS
// OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL NVIDIA OR ITS SUPPLIERS
// BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES
// WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS,
// BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY LOSS)
// ARISING OUT OF THE USE OF OR INABILITY TO USE THIS SOFTWARE, EVEN IF NVIDIA HAS
// BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES 

#pragma once
/** \file */

#include "nvsgcommon.h"
#include "nvmath/Plane3f.h"
#include "nvsg/Drawable.h"
#include "nvsg/Path.h"
#include "nvtraverser/ModelViewTraverser.h"

namespace nvsg
{
  class Camera;
}

namespace nvtraverser
{
  //! Intersection class.
  /** This class is used to store intersection results generated by the RayIntersectTraverser. 
    * It should only be used with classes derived from RayIntersectTraveser because some 
    * information like the distance makes sense only when knowing the ray data. 
     * \note Needs a valid ViewState. Call setViewState prior to apply().*/
  class Intersection
  {
    public:
      //! Default constructor.
      Intersection(void);

      //! Contructor.
      /** This contructor creates an intersection object from the given data.
        * It also performs an addRef() on the given path and drawable. */
      NVSG_API Intersection( const nvsg::Path * pPath          //!< Path to the intersected drawable.
                           , nvsg::DrawableHandle * pDrawable  //!< Intersected drawable.
                           , const nvmath::Vec3f & isp         //!< Intersection point on the drawable.
                           , float dist                        //!< Distance from the ray origin to the drawable.
                           , size_t primitiveIndex             //!< Index of the intersected primitive in the Drawable.
                           , const std::vector<unsigned int> & vertexIndices //!< Indices of the vertices of the intersected primitive.
                           );

      //! Copy constructor.
      /** Creates a new Intersection object from the given one. */
      NVSG_API Intersection( const Intersection & rhs    //!< Intersection object to copy from.
                           );

      //! Default destructor.
      NVSG_API virtual ~Intersection(void);

      //! Assignment operator.
      NVSG_API Intersection & operator = (const Intersection & rhs);

      //! Get the Path to the intersected drawable.
      /** \return Path to the drawable. */
      NVSG_API const nvsg::Path * getPath() const;

      //! Get the intersected drawable.
      /** \return Intersected drawable. */
      NVSG_API nvsg::DrawableHandle * getDrawable() const;

      //! Get the intersection point on the intersected drawable.
      /** \return Intersection Point. */
      NVSG_API const nvmath::Vec3f & getIsp() const;

      //! Get the distance from the ray origin to the intersection point.
      /** \return Distance from ray origin to intersection point. */
      NVSG_API float getDist() const;

      /*! \brief Get the index of the intersected primitive. 
       *  \return An index to the intersected primitive.
       *  \remarks This function returns the index of the intersected primitive.
       *  e.g. the i-th strip in a TriangleStrip or the i-th triangle in Triangles.
       *  With this index you have the abilitiy to access the primitive and modify it. */
      NVSG_API size_t getPrimitiveIndex() const;

      /*! \brief Get the indices if the intersected face, line or point.
       *  \return Indices to the vertex data of the intersected line, face or point.
       *  \remarks The vertices that are returned can be used to access the vertices of the 
       *  intersected object. 
       *  The size of this vector determines the primitive category. E.g. If the size of this vector 
       *  is 3 then the intersected face is a triangle. (4 is a Quad, 2 is a line, 1 a point...)
       *  \code
       *  // How to access the vertices and normals of the intersected triangle in a triangle strip
       *  const Vec3f * vertices = intersection->getDrawable()->getVertexAttributeSet()->getVertices();
       *  const Vec3f * normals = intersection->getDrawable()->getVertexAttributeSet()->getNormals();
       *  const IndexSet & strip = intersection->getDrawable()->getStrips()[intersection->getPrimitiveIndex()]; 
       *  const std::vector<unsigned int> & vertIndices = intersection->getVertexIndices(); 
       *
       *  const Vec3f & v0 = vertices[strip[vertIndices[0]]];
       *  const Vec3f & v1 = vertices[strip[vertIndices[1]]];
       *  const Vec3f & v2 = vertices[strip[vertIndices[2]]];
       * 
       *  const Vec3f & n0 = normals[strip[vertIndices[0]]];
       *  const Vec3f & n1 = normals[strip[vertIndices[1]]];
       *  const Vec3f & n2 = normals[strip[vertIndices[2]]];
       *  \endcode
       */
      NVSG_API const std::vector<unsigned int> & getVertexIndices() const;

    protected:
      //! Clone the whole object.
      /** Use this, for example, for the copy constructor. */
      NVSG_API void clone( const Intersection & rhs    //!< Object to clone.
                         ); 
      
      nvsg::DrawableHandle        * m_pDrawable;      //!< Intersected drawable.
      const nvsg::Path            * m_pPath;          //!< Path to the intersected drawable.
      nvmath::Vec3f                 m_isp;            //!< Intersection point on the intersected drawable.
      float                         m_dist;           //!< Distance from the ray origin to the intersection point.
      size_t                        m_primitiveIndex; //!< Index of the intersected primitive in the Drawable.
      std::vector<unsigned int>     m_vertexIndices;  //!< Indices of the vertices of the intersected primitive.

  };

  inline Intersection::~Intersection() 
  {
    if (m_pDrawable)
    {
      m_pDrawable->removeRef();
      m_pDrawable = NULL;
    }

    if (m_pPath)
    {
      m_pPath->removeRef();
      m_pPath = NULL;
    }
  }

  inline Intersection::Intersection()
  : m_pDrawable(NULL)
  , m_pPath(NULL)
  , m_isp(nvmath::Vec3f())
  , m_dist(0.0f)
  , m_primitiveIndex (0xffffffff)
  {
  }

   inline Intersection::Intersection ( const nvsg::Path * pPath
                                     , nvsg::DrawableHandle * pDrawable
                                     , const nvmath::Vec3f & isp
                                     , float dist
                                     , size_t primitiveIndex
                                     , const std::vector<unsigned int> & vertexIndices)

  {
    NVSG_ASSERT(pDrawable);
    NVSG_ASSERT(pPath);

    m_isp       = isp; 
    m_dist      = dist;
    
    m_pDrawable = pDrawable;
    m_pDrawable->addRef();

    m_pPath     = pPath;
    m_pPath->addRef();

    m_primitiveIndex = primitiveIndex;

    m_vertexIndices = vertexIndices;
  }

  inline Intersection::Intersection (const Intersection & rhs)
  {
    clone(rhs);
  }

  inline Intersection & Intersection::operator = (const Intersection & rhs) 
  {
    clone(rhs);
    return (*this);
  }

  inline void Intersection::clone(const Intersection & rhs)
  {
    m_isp       = rhs.m_isp; 
    m_dist      = rhs.m_dist; 
    
    m_pDrawable = rhs.m_pDrawable; 
    m_pDrawable->addRef();
    
    m_pPath     = rhs.m_pPath; 
    m_pPath->addRef();

    m_primitiveIndex = rhs.m_primitiveIndex;

    m_vertexIndices = rhs.m_vertexIndices;
  }

  inline const nvmath::Vec3f & Intersection::getIsp() const
  {
  return m_isp;
  }

  inline float Intersection::getDist() const
  {
    return m_dist;
  }

  inline nvsg::DrawableHandle * Intersection::getDrawable() const
  {
    return m_pDrawable;
  }

  inline const nvsg::Path * Intersection::getPath() const
  {
    return m_pPath;
  }

  inline size_t Intersection::getPrimitiveIndex() const
  {
    return m_primitiveIndex;
  }
  
  inline const std::vector<unsigned int> & Intersection::getVertexIndices() const
  {
    return m_vertexIndices;
  }

  //! RayIntersectTraverser
  /** A \a RayIntersectTraverser is a specialized traverser that calculates 
    * the intersections of a given ray that passes through the scene.
    * \note If you add new geometry objects classes to NVSG you must also derive from this class and 
    *  add an operator for this object to handle the intersection calculation.
    * \note If you create a special kind of transformation node you also have to 
    *  take care of the transformation stack in this class. 
    * \note Needs a valid ViewState. Call setViewState prior to apply().*/
  class RayIntersectTraverser : public SharedModelViewTraverser
  {
    public:
      //! Default constructor.
      NVSG_API RayIntersectTraverser(void);

      //! Release all resources.
      /** By releasing all resources we can use this traverser for the 
        * next intersection calculation. */
      NVSG_API void release();

      //! Set the ray for the intersection test.
      /** Sets a world-space ray along which to pick. The ray is defined as a world space 
        * \a origin point and \a direction vector. The direction vector must be normalized. */
      NVSG_API void setRay( const nvmath::Vec3f &origin      //!< World space origin
                          , const nvmath::Vec3f &dir         //!< Direction of the ray - must be normalized!
                          );

      //! Enable/disable camera plane clipping. 
      /** Enabling camera plane clipping forces the traverser to calculate only 
        * intersections that lie in between the camera's clip planes. */
      NVSG_API void setCamClipping( bool b    //!< true = enable clipping 
                                  );

      //! Get the nearest intersection.
      /** \returns The nearest intersection regarding the rays origin. */
      NVSG_API const Intersection & getNearest( void ) const;
      
      //! Get intersections.
      /** \returns All intersections along the ray. */
      NVSG_API const Intersection * getIntersections( void ) const;
      
      //! Get number of intersections.
      /** \returns The number of intersections along the ray. */
      NVSG_API size_t getNumberOfIntersections( void ) const;

      //! Set the viewport size for intersection calculations with lines and points
      /** \note Both width and height have to be positive. */
      NVSG_API void setViewportSize( size_t width, size_t height );

      
    protected:
      //! Default destructor.
      NVSG_API virtual ~RayIntersectTraverser(void);

      //! Apply the traverser to the scene.
      /** Start the intersection calculation of the given 
        * ray with the scene objects. */
      NVSG_API virtual void  doApply( nvsg::NodeHandle * root );

      // Nodes in the tree:
      NVSG_API virtual void handleGeoNode( const nvsg::GeoNode *gnode );
      NVSG_API virtual void handleVolumeNode( const nvsg::VolumeNode *vnode );
      
      // Groups in the tree:
      NVSG_API virtual void handleAnimatedTransform( const nvsg::AnimatedTransform *p );
      NVSG_API virtual void handleBillboard( const nvsg::Billboard * p);
      NVSG_API virtual void handleGroup( const nvsg::Group * group);
      NVSG_API virtual void handleLOD( const nvsg::LOD * lod);
      NVSG_API virtual void handleSwitch( const nvsg::Switch * swtch);
      NVSG_API virtual void handleTransform( const nvsg::Transform * p);

      // Other operators:
      NVSG_API virtual void handleAnimatedQuads( const nvsg::AnimatedQuads *quads );
      NVSG_API virtual void handleAnimatedTriangles( const nvsg::AnimatedTriangles *triangles );
      NVSG_API virtual void handleLines( const nvsg::Lines *lines );
      NVSG_API virtual void handleLineStrips( const nvsg::LineStrips *strips );
      NVSG_API virtual void handlePoints( const nvsg::Points *points );
      NVSG_API virtual void handleQuadMeshes( const nvsg::QuadMeshes *meshes );
      NVSG_API virtual void handleQuads( const nvsg::Quads *quads );
      NVSG_API virtual void handleQuadStrips( const nvsg::QuadStrips *strips );
      NVSG_API virtual void handleSkinnedTriangles( const nvsg::SkinnedTriangles *triangles );
      NVSG_API virtual void handleTriangles( const nvsg::Triangles *triangles );
      NVSG_API virtual void handleTriFans( const nvsg::TriFans *fans );
      NVSG_API virtual void handleTriStrips( const nvsg::TriStrips *strips );

      // Specialized state handling
      // handleFaceAttribute lets us evaluate backface culling for subsequent geometry.
      // Note, that we consider backface culling for picking!
      NVSG_API virtual void handleFaceAttribute( const nvsg::FaceAttribute *faceAttrib );
      NVSG_API virtual void handleStateSet( const nvsg::StateSet *stateSet );

      /*! \brief Store the active clip planes of \a p for later usage.
       *  \param p A pointer to the constant Group to get the active clip planes from.
       *  \return The result of ModelViewTraverser::preTraverseGroup().
       *  \sa postTraverseGroup */
      NVSG_API virtual bool preTraverseGroup( const nvsg::Group *p );

      /*! \brief Restore the set of active clip planes to the set before entering \a p.
       *  \param p A pointer to the constant Group just traversed.
       *  \remarks The clip planes stored in preTraverseGroup are removed.
       *  \sa preTraverseGroup */
      NVSG_API virtual void postTraverseGroup( const nvsg::Group *p );

      //! Handles actions to take between transform stack adjustment and traversal.
      /** Adjusts the ray origin and direction and the camera direction in model space.
        * \return result of the base class (ModelViewTraverser). */
      NVSG_API virtual bool preTraverseTransform( const nvmath::Trafo *p    //!< Trafo of node to traverse next 
                                                );

      //! Handles stuff to do between traversal and transform stack adjustment.
      /** Readjusts the ray origin and direction and the camera direction in model space. */
      NVSG_API virtual void postTraverseTransform( const nvmath::Trafo *p   //!< Trafo of node that was traversed immediately before this call. 
                                                 );

      /*! \brief Test a point against all active clip planes
       *  \param p A reference to a constant point to test against the clip planes.
       *  \return \c true if p is on the visible side of all active clip planes, otherwise \c false. */
      NVSG_API bool checkClipPlanes( const nvmath::Vec3f & p );

      /*! \brief Test a sphere against all active clip planes
       *  \param p A reference to a constant sphere to test agains the clip planes.
       *  \return \c true if p is at least partially on the visible side of all active clip planes,
       *  otherwise \c false. */
      NVSG_API bool checkClipPlanes( const nvmath::Sphere3f & p );

      //! %Intersection type (bounding sphere).
      /** These are the possible types of intersections between the ray 
        * and the boundingsphere of an object in the scene. These types 
        * are used for the preintersection calculation with the objects 
        * bounding sphere. Regarding the intersection type we can skip 
        * objects. */
      enum ISType { _NONE = 0       //!< No intersection
                  , _BSTANGENT      //!< Tangential intersection
                  , _BSNEAR         //!< Intersection with the front part of the bounding sphere
                  , _BSFAR          //!< Intersection with the back part of the bounding sphere
                  , _BSNEARFAR      //!< Intersection with the front and back part of the bounding sphere 
                  };

      //! Check the current ray for intersection with a \c Sphere3f.
      /** \return true, if the ray intersects \a sphere, otherwise false. */
      NVSG_API bool checkIntersection( const nvmath::Sphere3f &sphere );

      //! Get the intersection point in world coordinates.
      /** \return true: intersection in front of hte ray origin, false: no such intersection */
      NVSG_API bool getWorldIntersection( nvmath::Vec3f &isp  //!< Result: intersection point (world space)
                                                               , float &dist         //!< Input: distance in model space; Result: distance in world space
                                                               );

      //! Intersect with a box.
      /** This methods tells if it intersects a box or not.
        * It also calculates the intersection point between a box and a ray and the distance of
        * the intersection from the origin of the ray.
        * \returns true: intersection in front of the ray origin, false: no such intersection */
      NVSG_API bool intersectBox( const nvmath::Vec3f &p0   //!< lower left front point of box
                                , const nvmath::Vec3f &p1   //!< upper right back point of box
                                , nvmath::Vec3f &isp        //!< Result: intesection point (world space)
                                , float &dist               //!< Result: distance form camera to intersection
                                );

      //! Intersect with line.
      /** This method tells if it intersects the line or not. 
        * It also calculates the intersection point between line and ray and the distance 
        * of the intersection from the origin of the ray.
        * \returns true: intersection in front of the ray origin, false: no such intersection */
      NVSG_API bool intersectLine( const nvmath::Vec3f & v0  //!< First vertex of the line
                                 , const nvmath::Vec3f & v1  //!< Second vertex of the line
                                 , nvmath::Vec3f & isp       //!< Result: intersection point (world space)
                                 , float & dist              //!< Result: distance from camera to intersection
                                 );    

      //! Intersect with point.
      /** This method tells if it intersects the point or not. 
        * It also calculates the intersection point between point and ray and the distance 
        * of the intersection from the origin of the ray.
        * \returns true: intersection in front of the ray origin, false: no such intersection */
      NVSG_API bool intersectPoint( const nvmath::Vec3f & v0  //!< vertex of the point
                                  , nvmath::Vec3f & isp       //!< Result: intersection point (world space)
                                  , float & dist              //!< Result: distance from camera to intersection
                                  );    

      //! Intersect with triangle.
      /** This method tells if it intersects the triangle or not. 
        * It also calculates the intersection point between triangle and ray and the distance 
        * of the intersection from the origin of the ray.
        * \returns true: intersection in front of the ray origin, false: no such intersection */
      NVSG_API bool intersectTriangle( const nvmath::Vec3f & v0  //!< First vertex of the triangle
                                     , const nvmath::Vec3f & v1  //!< Second vertex of the triangle
                                     , const nvmath::Vec3f & v2  //!< Third vertex of the triangle
                                     , nvmath::Vec3f & isp       //!< Result: intersection point (world space)
                                     , float & dist              //!< Result: distance from camera to intersection
                                     );    

      //! Store the intersection point \a isp.
      /** If the point isn't clipped, it is stored to the intersection list.  */
      NVSG_API void storeIntersection( const nvsg::Drawable *p       //!< Drawable that holds the intersection
                                     , const nvmath::Vec3f &isp      //!< Intersection point
                                     , float dist                    //!< Distance from camera to intersection
                                     , size_t primitiveIndex         //!< Index of the intersected primitive
                                     , const std::vector<unsigned int> & vertexIndices //!< Indices of the vertices of the intersected primitive
                                     );

#if !defined(NDEBUG)
      /** Dump intersection map - for Debug*/
      NVSG_API void dumpIntersectionList();
#endif

    private:
      bool equal( nvmath::Vec3f v0, nvmath::Vec3f v1 ) const;
      bool lookForLineAttribute( const nvsg::StateSet *ss );
      bool lookForPointAttribute( const nvsg::StateSet *ss );
       
      static const nvmath::Vec3f _RAY_ORIGIN_DEFAULT;    //!< Default value: (0.f, 0.f,  0.f)
      static const nvmath::Vec3f _RAY_DIRECTION_DEFAULT; //!< Default value: (0.f, 0.f, -1.f)

      bool                        m_backFaceCulling;  //!< true: consider backface culling
      bool                        m_camClipping;      //!< true: use camera far/near clipping planes

      std::stack<std::vector<nvmath::Plane3f> > m_clipPlanes;   //!< vector of active clip planes
      nvsg::Path                * m_curPath;          //!< Current path.
      size_t                      m_currentFrame;     //!< This frame is to be used in an animation sequence.
      const nvsg::Camera        * m_lockedCamera;     //!< Camera of the scene that came in via apply - ViewState(we ref/unref it)
      std::vector<Intersection>   m_intersectionList; //!< Intersection list containing all intersections.
      float                       m_lineWidth;        //!< current line width
      float                       m_lineWidthDefault; //!< default line width
      std::stack<nvmath::Vec3f>   m_msRayOrigin;      //!< stack of Origin point of the ray in model space
      std::stack<nvmath::Vec3f>   m_msRayDir;         //!< stack of Direction of the ray in model space
      std::stack<nvmath::Vec3f>   m_msCamDir;         //!< stack of camera direction in model space
      size_t                      m_nearestIntIdx;    //!< Index of the nearest z intersection.
      float                       m_pointSize;        //!< current point size
      float                       m_pointSizeDefault; //!< default point size
      nvmath::Vec3f               m_rayOrigin;        //!< Origin point of the ray - default (0,0,0)
      nvmath::Vec3f               m_rayDir;           //!< Direction of the ray - default (0,0,-1)
      std::stack<float>           m_scaleFactors;
      size_t                      m_viewportHeight;
      size_t                      m_viewportWidth;
  };

  inline void RayIntersectTraverser::setCamClipping(bool flag)
  {
    m_camClipping = flag;
  }

  inline size_t RayIntersectTraverser::getNumberOfIntersections() const
  {
    return m_intersectionList.size();
  }

  inline const Intersection & RayIntersectTraverser::getNearest() const
  {
    NVSG_ASSERT(!m_intersectionList.empty());
    return m_intersectionList[m_nearestIntIdx];
  }
   
  inline const Intersection * RayIntersectTraverser::getIntersections() const
  {
    NVSG_ASSERT(!m_intersectionList.empty());
    return &m_intersectionList[0];
  }
}
